<code class="language-bash" style="color: rgb(0, 0, 0); background: transparent; font-family: var(--font-mono); white-space: pre-wrap;"><span><span class="token token" style="color: rgb(112, 184, 255);">cat</span><span> </span><span class="token token" style="color: rgb(234, 236, 240);">&gt;</span><span> /home/claude/cement_optimization_pinn/models/physics_loss.py </span><span class="token token" style="color: rgb(234, 236, 240);">&lt;&lt;</span><span> </span><span class="token token" style="color: rgb(155, 233, 99);">'EOFILE'
</span></span><span>"""
</span><span>Physics Loss Module for MT-PINN
</span><span>Implements conservation laws and chemistry constraints
</span><span>"""
</span><span>
</span><span>import numpy as np
</span><span>
</span><span>
</span><span>class PhysicsLoss:
</span><span>    """
</span><span>    Calculates physics-based loss terms to enforce:
</span><span>    1. Mass balance
</span><span>    2. Element conservation
</span><span>    3. Energy conservation
</span><span>    4. Stoichiometric relationships
</span><span>    5. Phase composition
</span><span>    """
</span><span>    
</span><span>    def __init__(self, weight=0.1):
</span><span>        """
</span><span>        Initialize physics loss calculator
</span><span>        
</span><span>        Parameters:
</span><span>        -----------
</span><span>        weight : float
</span><span>            Weight for physics loss in total loss (lambda)
</span><span>        """
</span><span>        self.weight = weight
</span><span>        
</span><span>        # Constants
</span><span>        self.CO2_fraction = 0.44  # kg CO2 per kg CaCO3
</span><span>        self.calcination_emission = 0.525  # kg CO2 per kg clinker
</span><span>    
</span><span>    def mass_balance_loss(self, inputs, predictions):
</span><span>        """
</span><span>        Mass balance: inputs = outputs + emissions
</span><span>        
</span><span>        Parameters:
</span><span>        -----------
</span><span>        inputs : dict or np.ndarray
</span><span>            Input features with blend percentages
</span><span>        predictions : dict
</span><span>            Predicted outputs
</span><span>        
</span><span>        Returns:
</span><span>        --------
</span><span>        float : Mass balance error
</span><span>        """
</span><span>        # Extract clinker percentage
</span><span>        if isinstance(inputs, dict):
</span><span>            clinker_pct = inputs['clinker_pct']
</span><span>        else:
</span><span>            clinker_pct = inputs[:, 0] if inputs.ndim &gt; 1 else inputs[0]
</span><span>        
</span><span>        # Predicted emissions
</span><span>        predicted_emissions = predictions['emissions']
</span><span>        
</span><span>        # Expected emissions based on clinker content
</span><span>        expected_emissions = clinker_pct / 100 * self.calcination_emission + 0.15  # +0.15 for fuel
</span><span>        
</span><span>        # Mass balance error
</span><span>        error = np.mean((predicted_emissions - expected_emissions)**2)
</span><span>        
</span><span>        return error
</span><span>    
</span><span>    def element_conservation_loss(self, inputs, predictions):
</span><span>        """
</span><span>        Element conservation: Ca, Si, Al, Fe should be conserved
</span><span>        
</span><span>        Parameters:
</span><span>        -----------
</span><span>        inputs : dict or np.ndarray
</span><span>            Input oxide compositions
</span><span>        predictions : dict
</span><span>            Predicted outputs
</span><span>        
</span><span>        Returns:
</span><span>        --------
</span><span>        float : Element conservation error
</span><span>        """
</span><span>        # Simplified: check that strength correlates with CaO
</span><span>        # In a full implementation, would track all elements
</span><span>        
</span><span>        if isinstance(inputs, dict):
</span><span>            cao = inputs.get('CaO', 65)
</span><span>            sio2 = inputs.get('SiO2', 21)
</span><span>        else:
</span><span>            # Assuming columns 4 and 5 are CaO and SiO2
</span><span>            cao = inputs[:, 4] if inputs.ndim &gt; 1 else inputs[4]
</span><span>            sio2 = inputs[:, 5] if inputs.ndim &gt; 1 else inputs[5]
</span><span>        
</span><span>        strength = predictions['strength']
</span><span>        
</span><span>        # CaO should positively correlate with strength
</span><span>        # Normalized correlation check
</span><span>        expected_strength_trend = (cao - 60) / 7 * 10 + 40  # Linear approximation
</span><span>        
</span><span>        error = np.mean((strength - expected_strength_trend)**2) / 100
</span><span>        
</span><span>        return error
</span><span>    
</span><span>    def energy_conservation_loss(self, inputs, predictions):
</span><span>        """
</span><span>        Energy conservation: E_in = E_out + E_loss
</span><span>        
</span><span>        Parameters:
</span><span>        -----------
</span><span>        inputs : dict or np.ndarray
</span><span>            Input features
</span><span>        predictions : dict
</span><span>            Predicted outputs
</span><span>        
</span><span>        Returns:
</span><span>        --------
</span><span>        float : Energy conservation error
</span><span>        """
</span><span>        # Extract kiln temperature and fuel input
</span><span>        if isinstance(inputs, dict):
</span><span>            kiln_temp = inputs.get('kiln_temp', 1450)
</span><span>            fuel_input = inputs.get('fuel_input', 100)
</span><span>        else:
</span><span>            kiln_temp = inputs[:, 8] if inputs.ndim &gt; 1 else inputs[8]
</span><span>            fuel_input = inputs[:, 10] if inputs.ndim &gt; 1 else inputs[10]
</span><span>        
</span><span>        # Higher temperature and fuel should increase emissions
</span><span>        expected_emissions = (fuel_input / 100) * 0.3 + 0.5  # Simplified
</span><span>        predicted_emissions = predictions['emissions']
</span><span>        
</span><span>        error = np.mean((predicted_emissions - expected_emissions)**2)
</span><span>        
</span><span>        return error
</span><span>    
</span><span>    def stoichiometry_loss(self, inputs, predictions):
</span><span>        """
</span><span>        Stoichiometric CO2 production from calcination
</span><span>        
</span><span>        CaCO3 -&gt; CaO + CO2 (1:1 molar, 0.44 mass ratio)
</span><span>        
</span><span>        Parameters:
</span><span>        -----------
</span><span>        inputs : dict or np.ndarray
</span><span>            Input features
</span><span>        predictions : dict
</span><span>            Predicted outputs
</span><span>        
</span><span>        Returns:
</span><span>        --------
</span><span>        float : Stoichiometry error
</span><span>        """
</span><span>        # Extract clinker percentage
</span><span>        if isinstance(inputs, dict):
</span><span>            clinker_pct = inputs['clinker_pct']
</span><span>        else:
</span><span>            clinker_pct = inputs[:, 0] if inputs.ndim &gt; 1 else inputs[0]
</span><span>        
</span><span>        # CO2 from calcination (simplified)
</span><span>        calcination_co2 = (clinker_pct / 100) * self.calcination_emission
</span><span>        
</span><span>        # Predicted total emissions should be at least calcination CO2
</span><span>        predicted_emissions = predictions['emissions']
</span><span>        
</span><span>        # Emissions should be &gt;= calcination (can be more due to fuel)
</span><span>        # Penalize if emissions &lt; calcination_co2
</span><span>        underprediction = np.maximum(0, calcination_co2 - predicted_emissions)
</span><span>        
</span><span>        error = np.mean(underprediction**2)
</span><span>        
</span><span>        return error
</span><span>    
</span><span>    def phase_composition_loss(self, inputs, predictions):
</span><span>        """
</span><span>        Clinker phase composition constraint
</span><span>        
</span><span>        C3S + C2S + C3A + C4AF ≈ 100%
</span><span>        
</span><span>        Parameters:
</span><span>        -----------
</span><span>        inputs : dict or np.ndarray
</span><span>            Input features
</span><span>        predictions : dict
</span><span>            Predicted outputs
</span><span>        
</span><span>        Returns:
</span><span>        --------
</span><span>        float : Phase composition error
</span><span>        """
</span><span>        # Simplified: strength depends on phase composition
</span><span>        # High clinker -&gt; high C3S -&gt; high strength
</span><span>        
</span><span>        if isinstance(inputs, dict):
</span><span>            clinker_pct = inputs['clinker_pct']
</span><span>        else:
</span><span>            clinker_pct = inputs[:, 0] if inputs.ndim &gt; 1 else inputs[0]
</span><span>        
</span><span>        strength = predictions['strength']
</span><span>        
</span><span>        # Higher clinker should mean higher strength
</span><span>        expected_min_strength = (clinker_pct / 100) * 35 + 10
</span><span>        
</span><span>        # Penalize if strength is below expected
</span><span>        underprediction = np.maximum(0, expected_min_strength - strength)
</span><span>        
</span><span>        error = np.mean(underprediction**2) / 100
</span><span>        
</span><span>        return error
</span><span>    
</span><span>    def calculate_total_physics_loss(self, inputs, predictions):
</span><span>        """
</span><span>        Calculate total physics loss as weighted sum
</span><span>        
</span><span>        Parameters:
</span><span>        -----------
</span><span>        inputs : dict or np.ndarray
</span><span>            Input features
</span><span>        predictions : dict
</span><span>            Predicted outputs
</span><span>        
</span><span>        Returns:
</span><span>        --------
</span><span>        dict : Individual and total physics losses
</span><span>        """
</span><span>        losses = {
</span><span>            'mass_balance': self.mass_balance_loss(inputs, predictions),
</span><span>            'element_conservation': self.element_conservation_loss(inputs, predictions),
</span><span>            'energy_conservation': self.energy_conservation_loss(inputs, predictions),
</span><span>            'stoichiometry': self.stoichiometry_loss(inputs, predictions),
</span><span>            'phase_composition': self.phase_composition_loss(inputs, predictions)
</span><span>        }
</span><span>        
</span><span>        # Total physics loss
</span><span>        total = sum(losses.values())
</span><span>        losses['total'] = total
</span><span>        
</span><span>        return losses
</span><span>    
</span><span>    def __call__(self, inputs, predictions):
</span><span>        """Make the class callable"""
</span><span>        return self.calculate_total_physics_loss(inputs, predictions)
</span><span>
</span><span>
</span><span># Example usage
</span><span>if __name__ == "__main__":
</span><span>    print("="*60)
</span><span>    print("PHYSICS LOSS MODULE TEST")
</span><span>    print("="*60)
</span><span>    
</span><span>    # Create physics loss calculator
</span><span>    physics_loss = PhysicsLoss(weight=0.2)
</span><span>    
</span><span>    # Test with sample data
</span><span>    print("\nTest Case 1: High clinker, should have high emissions")
</span><span>    inputs = {
</span><span>        'clinker_pct': 90,
</span><span>        'fly_ash_pct': 5,
</span><span>        'slag_pct': 3,
</span><span>        'limestone_pct': 2,
</span><span>        'CaO': 65,
</span><span>        'SiO2': 21,
</span><span>        'kiln_temp': 1470,
</span><span>        'fuel_input': 110
</span><span>    }
</span><span>    
</span><span>    predictions = {
</span><span>        'strength': np.array([48.0]),
</span><span>        'emissions': np.array([0.75]),
</span><span>        'cost': np.array([65.0]),
</span><span>        'risk': np.array([0.12])
</span><span>    }
</span><span>    
</span><span>    losses = physics_loss(inputs, predictions)
</span><span>    
</span><span>    print("\nPhysics Loss Components:")
</span><span>    for name, value in losses.items():
</span><span>        print(f"  {name:25s}: {value:.6f}")
</span><span>    
</span><span>    print("\nTest Case 2: Low clinker, should have lower emissions")
</span><span>    inputs['clinker_pct'] = 70
</span><span>    predictions['emissions'] = np.array([0.55])
</span><span>    predictions['strength'] = np.array([38.0])
</span><span>    
</span><span>    losses = physics_loss(inputs, predictions)
</span><span>    
</span><span>    print("\nPhysics Loss Components (Low Clinker):")
</span><span>    for name, value in losses.items():
</span><span>        print(f"  {name:25s}: {value:.6f}")
</span><span>    
</span><span>    print("\n✓ Physics loss tests passed!")
</span><span><span class="token token" style="color: rgb(155, 233, 99);">EOFILE</span><span>
</span></span><span></span></code>